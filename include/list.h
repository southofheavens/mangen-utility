#ifndef LIST_H
#define LIST_H

#include <stdio.h>

typedef struct lnode lnode;

struct lnode    
{
    lnode *prev;
    lnode *next;
    void *elem;
};

typedef struct
{
    lnode *head;
    lnode *end;         /* Указатель на узел, который */            
    size_t size;        /* следует за последним фактическим узлом */
    size_t type_size;
} list;

typedef lnode * list_iterator;

/* Принимает в качестве аргументов сообщение об ошибке и количество указателей, */
/* переданных в функцию, которые необходимо проверить на равенство нулю. Если хотя бы */
/* один указатель равен нулю, сообщение об ошибке, переданное в функцию, выводится в поток */
/* ошибок, и программа завершается */
void check_null_pointers(char *msg, size_t arg_count, ...);

/* --------------------------------------------- */
/*           Конструктор / деструктор            */
/* --------------------------------------------- */

/* Инициализирует список */
/* Принимает в качестве аргументов указатель на список и размер типа элемента */
void list_init(list *, const size_t);

/* Очищает ресурсы, занятые списком */
/* Принимает указатель на список в качестве аргумента */
void list_destroy(list *);

/* --------------------------------------------- */
/*              Добавление элементов             */
/* --------------------------------------------- */

/* Добавляет элемент в конец списка */
/* Принимает в качестве аргументов указатель на список и переменную, значение */
/* которой мы хотим добавить в список */
/* Переменная должна быть lvalue (иметь адрес) */
#define lpush_back(lst,var) _lpush_back(lst,&(var))
void _lpush_back(list *, const void *);

/* Добавляет элемент в начало списка */
/* Принимает в качестве аргументов указатель на список и переменную, значение */
/* которой мы хотим добавить в список */
/* Переменная должна быть lvalue (иметь адрес) */
#define lpush_front(lst,var) _lpush_front(lst,&(var))
void _lpush_front(list *, const void *);

/* Вставляет элемент в список перед итератором */
/* Принимает в качестве аргументов указатель на список, итератор и переменную, значение которой */
/* мы хотим добавить в список */
/* Переменная должна быть lvalue (иметь адрес) */
#define linsert(lst,it,el) _linsert(lst,it,&(el))
void _linsert(list *, const list_iterator, const void *);

/* --------------------------------------------- */
/*              Удаление элементов               */
/* --------------------------------------------- */

/* Удаляет последний элемент списка */
/* Принимает указатель на список в качестве аргумента */
void lpop_back(list *);

/* Удаляет первый элемент списка */
/* Принимает указатель на список в качестве аргумента */
void lpop_front(list *);

/* Удаляет элемент списка на который указывает итератор */
/* Принимает указатель на список и итератор в качестве аргументов */
void lerase(list *, list_iterator);

/* --------------------------------------------- */
/*               Изменение размера               */
/* --------------------------------------------- */

/* Изменяет размер списка */
/* Принимает в качестве аргументов указатель на список, новый размер и переменную, значение которой */
/* будет использоваться по умолчанию, если новый размер больше текущего размера списка */
/* Переменная должна быть lvalue (иметь адрес) */
#define lresize(lst,new_size,var) _lresize(lst,new_size,&(var))
void _lresize(list *, const size_t, const void *);

/* Очищает список */
/* Принимает указатель на список в качестве аргумента */
void lclear(list *);

/* --------------------------------------------- */
/*               Доступ к элементам              */
/* --------------------------------------------- */

/* Возвращает первый элемент списка */
/* Принимает в качестве аргументов указатель на список и возвращаемый тип (тип */
/* элементов, хранящихся в списке) */
#define lfront(lst,type) (*((type *)_lfront(lst)))
void *_lfront(const list *);

/* Возвращает последний элемент списка */
/* Принимает в качестве аргументов указатель на список и возвращаемый тип (тип */
/* элементов, хранящихся в списке) */
#define lback(lst,type) (*((type *)_lback(lst)))
void *_lback(const list *);

/* --------------------------------------------- */
/*             Изменение элементов               */
/* --------------------------------------------- */

/* Заменяет значение элемента, на который указывает итератор */
/* Принимает в качестве аргументов указатель на список, итератор и переменную, значение которой будет */
/* использоваться как новое значение переменной, на которую указывает итератор */
/* Переменная должна быть lvalue (иметь адрес) */
#define lset(lst,it,var) _lset(lst,it,&(var))
void _lset(list *, list_iterator, const void *);

/* Меняет местами содержимое двух списков */
/* Принимает указатели на списки в качестве аргументов */
void lswap(list *, list *);

/* --------------------------------------------- */
/*              Работа с итераторами             */
/* --------------------------------------------- */

/* Возвращает итератор, указывающий на первый элемент списка */
/* Принимает указатель на список в качестве аргумента */
list_iterator lbegin(const list *);

/* Возвращает итератор, указывающий на элемент, следующий за последним */
/* Принимает указатель на список в качестве аргумента */
list_iterator lend(const list *);

/* Перемещает итератор на указанное количество элементов */
/* Принимает в качестве аргументов указатель на итератор и количество сдвигов (отрицательное */
/* число означает, что мы движемся назад, положительное число означает, что мы движемся вперед) */
void ladvance(list_iterator *, const int);

/* Возвращает значение элемента, на который указывает итератор (разыменовывает итератор) */
/* Принимает в качестве аргументов итератор и возвращаемый тип (тип элемента, на который указывает */
/* итератор) */
#define lderef(it,type) (*((type *)_lderef(it)))
void *_lderef(const list_iterator);

/* --------------------------------------------- */
/*             Информация о списке               */
/* --------------------------------------------- */

/* Возвращает размер списка */
/* Принимает в качестве аргумента указатель на список */
size_t lsize(const list *);

/* Возвращает положительное значение, если список пустой, и ноль в противном случае */
/* Принимает в качестве аргумента указатель на список */
unsigned lempty(const list *); 

/* --------------------------------------------- */
/*                     Поиск                     */
/* --------------------------------------------- */

/* Ищет элемент в списке и возвращает итератор, указывающий на первое вхождение элемента */
/* Принимает в качестве аргументов указатель на список, переменную, значение которой мы */
/* хотим найти, и компаратор */
/* Переменная должна быть lvalue (иметь адрес) */
#define lfind(lst,var,comp) _lfind(lst,&(var),comp)
list_iterator _lfind(const list *, const void *, int (*)(const void *, const void *)); 

#endif